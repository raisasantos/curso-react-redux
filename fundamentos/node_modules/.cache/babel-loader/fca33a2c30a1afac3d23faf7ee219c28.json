{"ast":null,"code":"var _jsxFileName = \"/home/ray/\\xC1rea de Trabalho/estudos/curso-react/fundamentos-react/src/components/mega/Mega.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default _s(props => {\n  _s();\n\n  function gerarNumeroNaoContido(min, max, array) {\n    const aleatorio = parseInt(Math.random() * (max + 1 - min)) + min;\n    return array.includes(aleatorio) ? gerarNumeroNaoContido(min, max, array) : aleatorio;\n  }\n\n  function gerarNumeros(qtde) {\n    const numeros = Array(qtde).fill(0).reduce(nums => {\n      const novoNumero = gerarNumeroNaoContido(1, 60, nums);\n      return [...nums, novoNumero];\n    }, []).sort((n1, n2) => n1 - n2); //Ordem crescente\n\n    return numeros;\n  }\n\n  const numerosIniciais = Array(props.qtde || 6).fill(0);\n  const [numeros, setNumero] = useState(numerosIniciais);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Mega\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: numeros.join()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 27,\n    columnNumber: 9\n  }, this);\n}, \"ctW39F4is+GWylmqmnjqliAEiPw=\");\n/* O que é ?\n\n- Join() Os elementos da string serão separados por um separador especificado, podendo ser (, ) ( - ) (' ')...\n\n- O método includes() determina se um array/objeto contém um determinado elemento ou não, retornando true ou false \n\n- fill() \"preenche todos os valores do array\" a partir do índice inicial a um índice final com um valor estático.\n\n- reduce() busca reduzir um array. Ele iterará por cada elemento dessa lista com o objetivo de ao final gerar um único valor (de qualquer tipo), como por exemplo a soma de todos os elementos desse array. Lembrando que não ficamos presos apenas a números.\n*/\n\n/* Tem essa forma de fazer também\nfunction gerarNumeroNaoContido(array) {\n    let numAle = Math.floor(Math.random() * (60) + 1)\n    return array.includes(numAle) ? \n    gerarNumeroNaoContido(array):\n    numAle\n}\n \nfunction gerarNumeros(qtde) {\n    let nuns = []\n    for (let i = 1; i <= qtde; i++) {nuns.push(gerarNumeroNaoContido(nuns))}\n    return nuns\n}\n \nconsole.log(gerarNumeros(7))\n*/","map":{"version":3,"names":["React","useState","props","gerarNumeroNaoContido","min","max","array","aleatorio","parseInt","Math","random","includes","gerarNumeros","qtde","numeros","Array","fill","reduce","nums","novoNumero","sort","n1","n2","numerosIniciais","setNumero","join"],"sources":["/home/ray/Área de Trabalho/estudos/curso-react/fundamentos-react/src/components/mega/Mega.jsx"],"sourcesContent":["import React, { useState } from \"react\";\n\nexport default (props) => {\n\n    function gerarNumeroNaoContido(min, max, array) {\n        const aleatorio = parseInt(Math.random() * (max + 1 - min)) + min\n        return array.includes(aleatorio) ?\n            gerarNumeroNaoContido(min, max, array) : aleatorio\n    }\n    \n    function gerarNumeros(qtde) {\n        const numeros = Array(qtde)\n        .fill(0)\n        .reduce((nums) => {\n            const novoNumero = gerarNumeroNaoContido(1, 60, nums)\n            return [ ...nums, novoNumero ]\n        }, [])\n        .sort((n1, n2) => n1 - n2) //Ordem crescente\n    \n        return numeros\n    }    \n\n    const numerosIniciais = (Array(props.qtde || 6).fill(0))\n    const [numeros, setNumero] = useState(numerosIniciais)\n\n    return (\n        <div>\n            <h2>Mega</h2>\n            <h3>{numeros.join()}</h3>\n        </div>\n    );\n};\n\n/* O que é ?\n\n- Join() Os elementos da string serão separados por um separador especificado, podendo ser (, ) ( - ) (' ')...\n\n- O método includes() determina se um array/objeto contém um determinado elemento ou não, retornando true ou false \n\n- fill() \"preenche todos os valores do array\" a partir do índice inicial a um índice final com um valor estático.\n\n- reduce() busca reduzir um array. Ele iterará por cada elemento dessa lista com o objetivo de ao final gerar um único valor (de qualquer tipo), como por exemplo a soma de todos os elementos desse array. Lembrando que não ficamos presos apenas a números.\n*/\n\n\n/* Tem essa forma de fazer também\nfunction gerarNumeroNaoContido(array) {\n    let numAle = Math.floor(Math.random() * (60) + 1)\n    return array.includes(numAle) ? \n    gerarNumeroNaoContido(array):\n    numAle\n}\n \nfunction gerarNumeros(qtde) {\n    let nuns = []\n    for (let i = 1; i <= qtde; i++) {nuns.push(gerarNumeroNaoContido(nuns))}\n    return nuns\n}\n \nconsole.log(gerarNumeros(7))\n*/\n\n\n"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,QAAgC,OAAhC;;AAEA,kBAAgBC,KAAD,IAAW;EAAA;;EAEtB,SAASC,qBAAT,CAA+BC,GAA/B,EAAoCC,GAApC,EAAyCC,KAAzC,EAAgD;IAC5C,MAAMC,SAAS,GAAGC,QAAQ,CAACC,IAAI,CAACC,MAAL,MAAiBL,GAAG,GAAG,CAAN,GAAUD,GAA3B,CAAD,CAAR,GAA4CA,GAA9D;IACA,OAAOE,KAAK,CAACK,QAAN,CAAeJ,SAAf,IACHJ,qBAAqB,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,CADlB,GACsCC,SAD7C;EAEH;;EAED,SAASK,YAAT,CAAsBC,IAAtB,EAA4B;IACxB,MAAMC,OAAO,GAAGC,KAAK,CAACF,IAAD,CAAL,CACfG,IADe,CACV,CADU,EAEfC,MAFe,CAEPC,IAAD,IAAU;MACd,MAAMC,UAAU,GAAGhB,qBAAqB,CAAC,CAAD,EAAI,EAAJ,EAAQe,IAAR,CAAxC;MACA,OAAO,CAAE,GAAGA,IAAL,EAAWC,UAAX,CAAP;IACH,CALe,EAKb,EALa,EAMfC,IANe,CAMV,CAACC,EAAD,EAAKC,EAAL,KAAYD,EAAE,GAAGC,EANP,CAAhB,CADwB,CAOG;;IAE3B,OAAOR,OAAP;EACH;;EAED,MAAMS,eAAe,GAAIR,KAAK,CAACb,KAAK,CAACW,IAAN,IAAc,CAAf,CAAL,CAAuBG,IAAvB,CAA4B,CAA5B,CAAzB;EACA,MAAM,CAACF,OAAD,EAAUU,SAAV,IAAuBvB,QAAQ,CAACsB,eAAD,CAArC;EAEA,oBACI;IAAA,wBACI;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QADJ,eAEI;MAAA,UAAKT,OAAO,CAACW,IAAR;IAAL;MAAA;MAAA;MAAA;IAAA,QAFJ;EAAA;IAAA;IAAA;IAAA;EAAA,QADJ;AAMH,CA7BD;AA+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}